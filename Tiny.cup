package asint;
// TODO Todo lo que hay en el preambulo esta copiado, asumo que habra cosas que cambiar
import java_cup.runtime.*;
import alex.AnalizadorLexicoTiny;
import alex.UnidadLexica;
import errors.GestionErroresTiny;

scan with {: return getScanner().next_token(); :};
parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoTiny alex = (AnalizadorLexicoTiny)getScanner();
   alex.fijaGestionErrores(errores);
:};


terminal        INTEGER, ID, INT_T,SUM_OP, SUBS_OP,
                MULT_OP, DIV_OP, POW_OP, PARENTESIS_OPEN,
                PARENTESIS_CLOSE, BRACKET_OPEN, BRACKET_CLOSE,
                SQ_BRACKET_OPEN, SQ_BRACKET_CLOSE, LESS_OP,
                GREATER_OP, EQUAL_OP, LESS_OR_EQ_OP, GREATER_OR_EQ_OP,
                NOT_EQUAL_OP, BOOLEAN_T, AND_OP, OR_OP, NOT_OP, TRUE, FALSE,
                COMMA, COLON, SEMICOLON, CLASS_T, STRUCT_T, FIELD_ACCESS,
                FUNC_T, POINTER_OP, REFERENCE_OP, NEW_OP, TYPEDEF, DEFINE,
                ASSIGNATION_OP, IF, ELSE, SWITCH, CASE, BREAK,
                DEFAULT, WHILE, CONTINUE, INPUT_FUNC,
                OUTPUT_FUNC, RETURN, THIS, PUBLIC, PRIVATE, MAIN;

// TODO En los non terminal faltan por apuntar seguro
non terminal    S,
                BT, CLASS_EX,
                E0, E1, E2, E3, E4, OP_E0_BIN, OP_E0_UN, OP_E1, OP_E2, OP_E3,
                B0, B1, B2, B3, B4, OP_B0_B, OP_B0_E, OP_B1, OP_B2, OP_B3,
                TERM_SYM ;

// Grammar start

S     ::= S1 MAIN_INS ;
S1    ::= S1 BT | S1 FUNCTION | EPS ; // FIXME No se poner epsilon

// Big types

BT                  ::= CLASS_EX | STRUCT_EX | DEFINE_EX | TYPEDEF_EX SEMICOLON ;
CLASS_EX            ::= CLASS_T ID BRACKET_OPEN CLASS_BODY BRACKET_CLOSE SEMICOLON ;
CLASS_BODY          ::= VISIBILITY DECLARATION CLASS_BODY | METHOD_START SEMICOLON ;
METHOD_START        ::= ID PARENTESIS_OPEN ARGUMENTS PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY BRACKET_CLOSE METHODS ;
VISIBILITY          ::= PUBLIC | PRIVATE ;
METHODS             ::= METHODS VISIBILITY FUNCTION | EPS ;
DECLARATION         ::= TYPE ID SEMICOLON ;

// Functions

FUNCTION          ::= TYPED_FUNCTION | VOID_FUNCTION ;
TYPED_FUNCTION    ::= FUNC_T ID PARENTESIS_OPEN ARGUMENTS PARENTESIS_CLOSE COLON TYPE BRACKET_OPEN FUNCTION_BODY RETURN RETURN_VALUE SEMICOLON BRACKET_CLOSE ;
VOID_FUNCTION     ::= FUNC_T ID PARENTESIS_OPEN ARGUMENTS PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY RETURN SEMICOLON BRACKET_CLOSE ;
ARGUMENT_EX       ::= TYPE ID | TYPE REFERENCE ID ;
ARGUMENTS         ::= MORE_ARGUMENTS ARGUMENT_EX | EPS ; 
MORE_ARGUMENTS    ::= MORE_ARGUMENTS ARGUMENT_EX COMMA | EPS ;
FUNCTION_BODY     ::= FUNCTION_BODY INSTRUCTION | EPS ; // FIXME No se como se escribe epsilon
RETURN_VALUE      ::= LITERAL | ID_EX

// Define

DEFINE_EX   ::= DEFINE ID LITERAL SEMICOLON ;

// Typedef

TYPEDEF_EX  ::= TYPEDEF ID EXPRESSION SEMICOLON ;

// Asignation

ASSIGNATION_INS  ::= TYPE ID ASSIGNATION_OP EXPRESSION SEMICOLON ; | ID_EX ASSIGNATION_OP EXPRESSION SEMICOLON ; // TODO No se han considerado arrays, punteros, variables de clases, ...

// If

IF_INS      ::= IF PARENTESIS_OPEN EXPRESSION PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY BRACKET_CLOSE ELSE_INS ;
ELSE_INS    ::= ELSE BRACKET_OPEN FUNCTION_BODY BRACKET_CLOSE | EPS ; // FIXME No se como se escribe epsilon

// Switch

SWITCH_INS        ::= SWITCH PARENTESIS_OPEN ID_EX PARENTESIS_CLOSE BRACKET_OPEN CASES_INS DEFAULT_CASE BRACKET_CLOSE ;
CASES_INS         ::= CASES_INS CASE PARENTESIS_OPEN LITERAL PARENTESIS_CLOSE COLON FUNCTION_BODY OPTIONAL_BREAK | EPS;
DEFAULT_CASE      ::= DEFAULT COLON FUNCTION_BODY BREAK SEMICOLON ;
OPTIONAL_BREAK    ::= BREAK SEMICOLON | EPS ; // FIXME No se como se escribe epsilon

// While

WHILE_INS   ::= WHILE PARENTESIS_OPEN EXPRESSION PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY BRACKET_CLOSE ;

// I/O

IO_INS  ::= INPUT_INS | OUTPUT_INS ;
INPUT_INS   ::= INPUT_FUNC PARENTESIS_OPEN ID_EX PARENTESIS_CLOSE SEMICOLON ;
OUTPUT_INS  ::= OUTPUT_FUNC PARENTESIS_OPEN EXPRESSION PARENTESIS_CLOSE SEMICOLON ;

// Main

MAIN_INS    ::= FUNCTION MAIN PARENTESIS_OPEN PARENTESIS_CLOSE COLON INT_T BRACKET_OPEN FUNCTION_BODY RETURN INTEGER SEMICOLON BRACKET_CLOSE ;

// Arithmetic expresions

E0          ::= E0 OP_E0_BIN E1 | OP_E0_UN E1 | E1 ;
E1          ::= E1 OP_E1 E2 | E2 ;
E2          ::= E3 OP_E2 E3 | E3 ;
E3          ::= OP_E3 E4 | E4 ;
E4          ::= BRACKET_OPEN E0 BRACKET_CLOSE | TERM_SYM ;
OP_E0_BIN   ::= SUM_OP | SUBS_OP ; // Binary operators for E0
OP_E0_UN    ::= SUBS_OP ; // Unitary operators for E0
OP_E1       ::= MULT_OP | DIV_OP ;
OP_E2       ::= POW_OP ;
OP_E3       ::= POINTER_OP ;

// Boolean expresions

B0          ::= B1 OP_B0_B B1 | E0 OP_B0_E E0 | B1 ;
B1          ::= B1 OP_B1 B2 | B2 ;
B2          ::= B2 OP_B2 B3 | B3 ;
B3          ::= OP_B3 B4 | B4 ;
B4          ::= BRACKET_OPEN B0 BRACKET_CLOSE | TERM_SYM ;
OP_B0_B     ::= EQUAL_OP, NOT_EQUAL_OP ;
OP_B0_E     ::= OP_B0_B | LESS_OR_EQ_OP | GREATER_OR_EQ_OP | GREATER_OP | LESS_OP ;
OP_B1       ::= OR_OP ;
OP_B2       ::= AND_OP ;
OP_B3       ::= NOT_OP ;

// Frequently used expresions
TERM_SYM             ::= //TODO  Expresion for terminal symbols in arithmetic and/or boolean operations
TYPE                 ::= INT_T | BOOLEAN_T | TYPE POINTER_OP | TYPE SQ_BRACKET_OPEN INTEGER SQ_BRACKET_CLOSE | ID ; // REVIEW Revisar lo de necesitar ID para tipos definidos por el usuario
INSTRUCTION          ::= ASSIGNATION_INS | IF_INS | SWITCH_INS | WHILE_INS | IO_INS | SEMICOLON ; // The last semicolon represents an empty instruction
EXPRESSION           ::= // TODO
ID_EX                ::= THIS FIELD_ACCESS ID | ID ;
LITERAL              ::= INTEGER | TRUE | FALSE ;