package syntax;

import java_cup.runtime.*;
import lexicon.AnalizadorLexicoTiny;
import lexicon.LexiconUnit;
import errors.GestionErroresTiny;

scan with {: return getScanner().next_token(); :};
parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((LexiconUnit)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoTiny alex = (AnalizadorLexicoTiny)getScanner();
   alex.fijaGestionErrores(errores);
:};


terminal        INTEGER, ID, INT_T,SUM_OP, SUBS_OP,
                MULT_OP, DIV_OP, MOD_OP, POW_OP, PARENTESIS_OPEN,
                PARENTESIS_CLOSE, BRACKET_OPEN, BRACKET_CLOSE,
                SQ_BRACKET_OPEN, SQ_BRACKET_CLOSE, LESS_OP,
                GREATER_OP, EQUAL_OP, LESS_OR_EQ_OP, GREATER_OR_EQ_OP,
                NOT_EQUAL_OP, BOOLEAN_T, AND_OP, OR_OP, NOT_OP, TRUE, FALSE,
                COMMA, COLON, SEMICOLON, CLASS_T, STRUCT_T, FIELD_ACCESS,
                FUNC_T, POINTER_OP, REFERENCE_OP, NEW_OP, TYPEDEF, DEFINE,
                ASSIGNATION_OP, IF, ELSE, SWITCH, CASE, BREAK,
                DEFAULT, WHILE, FOR, CONTINUE, INPUT_FUNC,
                OUTPUT_FUNC, RETURN, THIS, PUBLIC, PRIVATE, MAIN;

non terminal    S, S1,
                DEF, CLASS_INIT, MORE_CONSTRUCTORS, CONSTRUCTOR, VISIBILITY, METHODS, DECLARATIONS_STRUCT, DECLARATIONS_CLASS, DECLARATION, ARRAY_CONSTRUCTOR,
                TYPED_FUNCTION, VOID_FUNCTION, ARGUMENT, ARGUMENTS, MORE_ARGUMENTS, FUNCTION_BODY, RETURN_VALUE,
                
                TYPE_TYPEDEF,
                DECLARATION_AND_ASSIGNATION_INS, ASSIGNATION_INS,
                IF_INS, ELSE_INS,
                FOR_INS,
                IO_INS, INPUT_INS, OUTPUT_INS, ID_PARENTESIS
                ;
               
non terminal   Expression EXPRESSION, B0, B1, B2, B3, B4, E0, E1, E2, E3, E4, E5, E6;
                EXPRESSIONS, MORE_EXPRESSIONS, TERMINAL,
                TYPE, OPT_INTEGER, SENTENCE, ID_EX, LITERAL;

non terminal   Sentence SWITCH_INS, DEFAULT_CASE, WHILE_INS, BREAK_INS, CONTINUE_INS, FOR_INS, OPTIONAL_SENTENCE,
                        IO_INS, INPUT_INS, OUTPUT_INS;

non terminal   Definition MAIN_INS, CLASS_DEF, STRUCT_DEF, DEFINE_DEF, TYPEDEF_DEF, FUNCTION_DEF;

non terminal   Block FUNCTION_BODY;

non terminal   List<Sentence> CASES_INS;

// Grammar start
S     ::= S1 MAIN_INS ;
S1    ::= S1 DEF ;
S1    ::= /*EMPTY*/ ;

// Definitions
DEF                  ::= CLASS_DEF ;
DEF                  ::= STRUCT_DEF ;
DEF                  ::= DEFINE_DEF ;
DEF                  ::= TYPEDEF_DEF ;
DEF                  ::= FUNCTION_DEF ; 

CLASS_DEF            ::= CLASS_T ID BRACKET_OPEN DECLARATIONS_CLASS CLASS_INIT BRACKET_CLOSE ;
CLASS_INIT           ::= CONSTRUCTOR MORE_CONSTRUCTORS METHODS ;
MORE_CONSTRUCTORS    ::= MORE_CONSTRUCTORS CONSTRUCTOR;
MORE_CONSTRUCTORS    ::= /*EMPTY*/ ;
CONSTRUCTOR          ::= ID PARENTESIS_OPEN ARGUMENTS PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY BRACKET_CLOSE;
METHODS              ::= METHODS VISIBILITY FUNCTION_DEF ;
METHODS              ::= /*EMPTY*/ ;
VISIBILITY           ::= PUBLIC ;
VISIBILITY           ::= PRIVATE ;
DECLARATIONS_CLASS   ::= DECLARATIONS_CLASS VISIBILITY DECLARATION SEMICOLON ;
DECLARATIONS_CLASS   ::= /*EMPTY*/ ;


STRUCT_DEF           ::= STRUCT_T ID BRACKET_OPEN DECLARATIONS_STRUCT CONSTRUCTOR MORE_CONSTRUCTORS BRACKET_CLOSE ;
DECLARATIONS_STRUCT  ::= DECLARATIONS_STRUCT DECLARATION SEMICOLON;
DECLARATIONS_STRUCT  ::= /*EMPTY*/ ;

// Functions

FUNCTION_DEF      ::= TYPED_FUNCTION ;
FUNCTION_DEF      ::= VOID_FUNCTION ;
TYPED_FUNCTION    ::= FUNC_T ID PARENTESIS_OPEN ARGUMENTS PARENTESIS_CLOSE COLON TYPE BRACKET_OPEN FUNCTION_BODY RETURN RETURN_VALUE SEMICOLON BRACKET_CLOSE ;
VOID_FUNCTION     ::= FUNC_T ID PARENTESIS_OPEN ARGUMENTS PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY RETURN SEMICOLON BRACKET_CLOSE ;
ARGUMENTS         ::= MORE_ARGUMENTS ARGUMENT ;
ARGUMENTS         ::= /*EMPTY*/ ; 
MORE_ARGUMENTS    ::= MORE_ARGUMENTS ARGUMENT COMMA ;
MORE_ARGUMENTS    ::= /*EMPTY*/ ;
ARGUMENT          ::= DECLARATION ;
ARGUMENT          ::= TYPE REFERENCE_OP ID ARRAY_CONSTRUCTOR ; 
FUNCTION_BODY     ::= FUNCTION_BODY SENTENCE ;
FUNCTION_BODY     ::= /*EMPTY*/ ;
RETURN_VALUE      ::= EXPRESSION ;

// Define

DEFINE_DEF        ::= DEFINE ID LITERAL SEMICOLON ;

// Typedef

TYPEDEF_DEF    ::= TYPEDEF ID TYPE_TYPEDEF SEMICOLON ;
TYPE_TYPEDEF   ::= INT_T ;
TYPE_TYPEDEF   ::= BOOLEAN_T ;
TYPE_TYPEDEF   ::= ID ;
TYPE_TYPEDEF   ::= TYPE_TYPEDEF POINTER_OP ;
TYPE_TYPEDEF   ::= TYPE_TYPEDEF SQ_BRACKET_OPEN OPT_INTEGER SQ_BRACKET_CLOSE ;

// Assignation

DECLARATION                      ::= TYPE:t ID:i ARRAY_CONSTRUCTOR ;
// TODO {: RESULT = new Declaration(t, i) ; :};
ARRAY_CONSTRUCTOR                ::= ARRAY_CONSTRUCTOR SQ_BRACKET_OPEN OPT_INTEGER SQ_BRACKET_CLOSE ;
// TODO
ARRAY_CONSTRUCTOR                ::= /*EMPTY*/ ;
// TODO 
ID_PARENTESIS                    ::= ID PARENTESIS_OPEN EXPRESSIONS PARENTESIS_CLOSE ;
// TODO

DECLARATION_AND_ASSIGNATION_INS  ::= DECLARATION:dec ASSIGNATION_OP EXPRESSION:e SEMICOLON ;
{: RESULT = new DeclarationAndAssignation(dec, e); :};
DECLARATION_AND_ASSIGNATION_INS  ::= DECLARATION:dec ASSIGNATION_OP NEW_OP TYPE ARRAY_CONSTRUCTOR SEMICOLON ;
// TODO {: RESULT = new DeclarationAndAssignation(dec, new New_Op(e)); :};
DECLARATION_AND_ASSIGNATION_INS  ::= DECLARATION ASSIGNATION_OP NEW_OP ID_PARENTESIS SEMICOLON ;
// TODO
ASSIGNATION_INS                  ::= EXPRESSION:iz ASSIGNATION_OP EXPRESSION:dc SEMICOLON ;
{: RESULT = new Assignation_Ins(iz, dc) ; :};
ASSIGNATION_INS                  ::= EXPRESSION:iz NEW_OP TYPE ARRAY_CONSTRUCTOR SEMICOLON ;
// TODO {: RESULT = new Assignation_Ins(iz, new New_Op(dc)); :};
ASSIGNATION_INS                  ::= EXPRESSION ASSIGNATION_OP NEW_OP ID_PARENTESIS SEMICOLON ;
// TODO


// If

IF_INS      ::= IF PARENTESIS_OPEN EXPRESSION:cond PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY:if_body BRACKET_CLOSE ELSE_INS:else_body ;
{: RESULT = new If_Ins(cond, if_body, else_body); :};
ELSE_INS    ::= ELSE BRACKET_OPEN FUNCTION_BODY:body BRACKET_CLOSE ;
{: RESULT = body; :};
ELSE_INS    ::= /*EMPTY*/ ;
{: RESULT = new Block(new ArrayList<>()); :};


// Switch

SWITCH_INS        ::= SWITCH PARENTESIS_OPEN EXPRESSION:e PARENTESIS_CLOSE BRACKET_OPEN CASES_INS:array DEFAULT_CASE:default_case BRACKET_CLOSE ;
{: array.add(default_case); RESULT = new Switch_Ins(e, new Block(array)); :};
CASES_INS         ::= CASES_INS:array CASE PARENTESIS_OPEN LITERAL:cond PARENTESIS_CLOSE COLON FUNCTION_BODY:body ;
{: array.add(new Case_Ins(cond, body)) ; RESULT = array; :};
CASES_INS         ::= /*EMPTY*/;
{: RESULT = new ArrayList<>(); :};
DEFAULT_CASE      ::= DEFAULT COLON FUNCTION_BODY:body BREAK SEMICOLON ;
{: body.add_instruction(new Break_Ins()); RESULT = new Default_Ins(body); :};


// While

WHILE_INS      ::= WHILE PARENTESIS_OPEN EXPRESSION:cond PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY:body BRACKET_CLOSE ;
{: RESULT = new While_Ins(cond, body); :};
BREAK_INS      ::= BREAK SEMICOLON ;
{: RESULT = new Break_Ins(); :};
CONTINUE_INS   ::= CONTINUE SEMICOLON ;
{: RESULT = new Continue_Ins(); :};


// For

FOR_INS  ::= FOR PARENTESIS_OPEN OPTIONAL_SENTENCE:s1 SEMICOLON EXPRESSION:cond SEMICOLON OPTIONAL_SENTENCE:s2 PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY:body BRACKET_CLOSE ;
{: RESULT = new For_Ins(s1, cond, s2, body); :};
OPTIONAL_SENTENCE  ::= SENTENCE:s ;
{: RESULT = s; :};
OPTIONAL_SENTENCE  ::= /*EMPTY*/ ;
{: RESULT = new Empty_Ins(); :};


// I/O

IO_INS  ::= INPUT_INS:s ;
{: RESULT = s; :};
IO_INS  ::= OUTPUT_INS:s ;
{: RESULT = s; :};
INPUT_INS   ::= INPUT_FUNC PARENTESIS_OPEN EXPRESSION:e PARENTESIS_CLOSE SEMICOLON ;
{: RESULT = new Input_Ins(e); :};
OUTPUT_INS  ::= OUTPUT_FUNC PARENTESIS_OPEN EXPRESSION:e PARENTESIS_CLOSE SEMICOLON ;
{: RESULT = new Output_Ins(e); :};


// Main

MAIN_INS    ::= FUNC_T MAIN PARENTESIS_OPEN PARENTESIS_CLOSE COLON INT_T BRACKET_OPEN FUNCTION_BODY:body RETURN INTEGER SEMICOLON BRACKET_CLOSE ;
{:  :}; //TODO

// Boolean and arithmetic expresions

EXPRESSION        ::= B0:e ;
{: RESULT = e ; :};

B0                ::= B1:iz LESS_OR_EQ_OP B1:dc ;
{: RESULT = new Less_Or_Eq_Op(iz, dc); :};
B0                ::= B1:iz GREATER_OR_EQ_OP B1:dc ;
{: RESULT = new Greater_Or_Eq_Op(iz, dc); :};
B0                ::= B1:iz LESS_OP B1:dc ;
{: RESULT = new Less_Op(iz, dc); :};
B0                ::= B1:iz GREATER_OP B1:dc ;
{: RESULT = new Greater_Op(iz, dc); :};
B0                ::= B1:iz EQUAL_OP B1:dc ;
{: RESULT = new Equal_Op(iz, dc); :};
B0                ::= B1:iz NOT_EQUAL_OP B1:dc ;
{: RESULT = new Not_Equal_Op(iz, dc); :};
B0                ::= B1:e ;
{: RESULT = e; :};

B1                ::= B1:iz OR_OP B2:dc ;
{: RESULT = new Or_Op(iz, dc); :};
B1                ::= B2:e ;
{: RESULT = e; :};

B2                ::= B2:iz AND_OP B3:dc ;
{: RESULT = new And_Op(iz, dc); :}
B2                ::= B3:e ;
{: RESULT = e; :};

B3                ::= NOT_OP B4:e ;
{: RESULT = new Not_Op(e); :};
B3                ::= B4:e ;
{: RESULT = e; :};

B4                ::= E0:e ;
{: RESULT = e; :};

E0                ::= E0:iz SUM_OP E1:dc ;
{: RESULT = new Sum_Op(iz, dc); :};
E0                ::= E0:iz SUBS_OP E1:dc ;
{: RESULT = new Subs_Op(iz, dc); :};
E0                ::= SUBS_OP E1:e ;
{: RESULT = new Minus_Op(e); :};
E0                ::= E1:e ;
{: RESULT = e; :};

E1                ::= E1:iz MULT_OP E2:dc ;
{: RESULT = new Mult_Op(iz, dc); :};
E1                ::= E1:iz DIV_OP E2:dc ;
{: RESULT = new Div_Op(iz, dc); :};
E1                ::= E1:iz MOD_OP E2:dc ;
{: RESULT = new Mod_Op(iz, dc); :};
E1                ::= E2:e ;
{: RESULT = e; :};

E2                ::= E3:iz POW_OP E3:dc ;
{: RESULT = new Pow_Op(iz, dc); :};
E2                ::= E3:e ;
{: RESULT = e; :};

E3                ::= POINTER_OP E4:dc ;
{: RESULT = new Pointer_Op(dc); :};
E3                ::= E4:e ;
{: RESULT = e; :};

E4                ::= E5:iz FIELD_ACCESS E5:dc ;
{: RESULT = new Field_Access_Op(iz, dc); :};
E4                ::= E5:e ;
{: RESULT = e; :};

E5                ::= E5:iz SQ_BRACKET_OPEN EXPRESSION:dc SQ_BRACKET_CLOSE ;
{: RESULT = new Sq_Bracket_Op(iz, dc); :};
E5                ::= E6:e ;
{: RESULT = e; :};

E6                ::= PARENTESIS_OPEN EXPRESSION:e PARENTESIS_CLOSE ;
{: RESULT = e; :};
E6                ::= TERMINAL:e ;
{: RESULT = e; :};

EXPRESSIONS          ::= MORE_EXPRESSIONS:array EXPRESSION:e ;
{: array.add(e); RESULT = array :};
EXPRESSIONS          ::= /*EMPTY*/ ;
{: RESULT = new ArrayList<Expression>() :};
MORE_EXPRESSIONS     ::= MORE_EXPRESSIONS:array EXPRESSION:e COMMA ;
{: array.add(e); RESULT = array :};
MORE_EXPRESSIONS     ::= /*EMPTY*/ ;
{: RESULT = new ArrayList<Expression>() :};

TERMINAL             ::= LITERAL:e ;
{: RESULT = e; :};
TERMINAL             ::= ID_EX:e ;
{: RESULT = e; :};


// Frequently used expresions
TYPE                 ::= INT_T ;
TYPE                 ::= BOOLEAN_T ;
TYPE                 ::= ID ;
TYPE                 ::= TYPE POINTER_OP ;

OPT_INTEGER          ::= INTEGER ;
OPT_INTEGER          ::= ID ;
OPT_INTEGER          ::= /*EMPTY*/ ;

SENTENCE             ::= DECLARATION:e SEMICOLON ;
{: RESULT = e; :};
SENTENCE             ::= ASSIGNATION_INS:e ;
{: RESULT = e; :};
SENTENCE             ::= DECLARATION_AND_ASSIGNATION_INS:e ;
{: RESULT = e; :};
SENTENCE             ::= IF_INS:e ;
{: RESULT = e; :};
SENTENCE             ::= SWITCH_INS:e ;
{: RESULT = e; :};
SENTENCE             ::= WHILE_INS:e ;
{: RESULT = e; :};
SENTENCE             ::= FOR_INS:e ;
{: RESULT = e; :};
SENTENCE             ::= BREAK_INS:e ;
{: RESULT = e; :};
SENTENCE             ::= CONTINUE_INS:e ;
{: RESULT = e; :};
SENTENCE             ::= IO_INS:e ;
{: RESULT = e; :};
SENTENCE             ::= SEMICOLON ; // The last semicolon represents an empty instruction
{: RESULT = new Empty_Ins(); :};

ID_EX                ::= THIS FIELD_ACCESS ID:e ;
{: RESULT = new This_Op(e); :};
ID_EX                ::= ID:e ;
{: RESULT = new Id(e); :};
ID_EX                ::= ID_PARENTESIS:e ;
{: RESULT = e ; :}

LITERAL              ::= INTEGER:e ;
{: RESULT = new Int_Value(e); :};
LITERAL              ::= TRUE:e ;
{: RESULT = new Bool_Value(e); :};
LITERAL              ::= FALSE:e ;
{: RESULT = new Bool_Value(e); :};