package syntax;

import java_cup.runtime.*;
import lexicon.AnalizadorLexicoTiny;
import lexicon.LexiconUnit;
import errors.GestionErroresTiny;

scan with {: return getScanner().next_token(); :};
parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((LexiconUnit)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoTiny alex = (AnalizadorLexicoTiny)getScanner();
   alex.fijaGestionErrores(errores);
:};


terminal        INTEGER, ID, INT_T,SUM_OP, SUBS_OP,
                MULT_OP, DIV_OP, MOD_OP, POW_OP, PARENTESIS_OPEN,
                PARENTESIS_CLOSE, BRACKET_OPEN, BRACKET_CLOSE,
                SQ_BRACKET_OPEN, SQ_BRACKET_CLOSE, LESS_OP,
                GREATER_OP, EQUAL_OP, LESS_OR_EQ_OP, GREATER_OR_EQ_OP,
                NOT_EQUAL_OP, BOOLEAN_T, AND_OP, OR_OP, NOT_OP, TRUE, FALSE,
                COMMA, COLON, SEMICOLON, CLASS_T, STRUCT_T, FIELD_ACCESS,
                FUNC_T, POINTER_OP, REFERENCE_OP, NEW_OP, TYPEDEF, DEFINE,
                ASSIGNATION_OP, IF, ELSE, SWITCH, CASE, BREAK,
                DEFAULT, WHILE, FOR, CONTINUE, INPUT_FUNC,
                OUTPUT_FUNC, RETURN, THIS, PUBLIC, PRIVATE, MAIN;

non terminal    S, S1,
                BT, CLASS_EX, CLASS_BODY, CLASS_INIT, VISIBILITY, METHODS, STRUCT_EX, STRUCT_BODY, STRUCT_INIT, DECLARATIONS, DECLARATION,
                FUNCTION, TYPED_FUNCTION, VOID_FUNCTION, ARGUMENT_EX, ARGUMENTS, MORE_ARGUMENTS, FUNCTION_BODY, RETURN_VALUE,
                DEFINE_EX,
                TYPEDEF_EX, TYPE_TYPEDEF,
                DECLARATION_AND_ASSIGNATION_INS, ASSIGNATION_INS,
                IF_INS, ELSE_INS,
                SWITCH_INS, CASES_INS, DEFAULT_CASE,
                WHILE_INS, BREAK_INS, CONTINUE_INS,
                FOR_INS, OPTIONAL_EXPRESSION,
                IO_INS, INPUT_INS, OUTPUT_INS,
                MAIN_INS,
                EXPRESSION,
                B0, B1, B2, B3, B4, E0, E1, E2, E3, E4, E5, E6,
                OP_B0, OP_B1, OP_B2, OP_B3, OP_E0_BIN, OP_E0_UN, OP_E1, OP_E2, OP_E3, OP_E4,
                EXPRESSIONS, MORE_EXPRESSIONS, TERMINAL,
                TYPE, ID_OR_IDBRACKETS, OPT_INTEGER, INSTRUCTION, ID_EX, LITERAL;

// Grammar start
S     ::= S1 MAIN_INS ;
S1    ::= S1 BT ;
S1    ::= S1 FUNCTION ;
S1    ::= /*EMPTY*/ ;

// Big types
BT                   ::= CLASS_EX ;
BT                   ::= STRUCT_EX ;
BT                   ::= DEFINE_EX ;
BT                   ::= TYPEDEF_EX ;

CLASS_EX             ::= CLASS_T ID BRACKET_OPEN CLASS_BODY BRACKET_CLOSE ;
CLASS_BODY           ::= DECLARATIONS CLASS_INIT ;
CLASS_INIT           ::= ID PARENTESIS_OPEN ARGUMENTS PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY BRACKET_CLOSE METHODS ;
VISIBILITY           ::= PUBLIC ;
VISIBILITY           ::= PRIVATE ;
METHODS              ::= METHODS VISIBILITY FUNCTION ;
METHODS              ::= /*EMPTY*/ ;

STRUCT_EX            ::= STRUCT_T ID BRACKET_OPEN STRUCT_BODY BRACKET_CLOSE ;
STRUCT_BODY          ::= DECLARATION STRUCT_BODY ;
STRUCT_BODY          ::= STRUCT_INIT ;
STRUCT_INIT          ::= ID PARENTESIS_OPEN ARGUMENTS PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY BRACKET_CLOSE ;
DECLARATIONS         ::= DECLARATIONS VISIBILITY DECLARATION ;
DECLARATIONS         ::= /*EMPTY*/ ;
DECLARATION          ::= TYPE ID_OR_IDBRACKETS SEMICOLON ;

// Functions

FUNCTION          ::= TYPED_FUNCTION ;
FUNCTION          ::= VOID_FUNCTION ;
TYPED_FUNCTION    ::= FUNC_T ID PARENTESIS_OPEN ARGUMENTS PARENTESIS_CLOSE COLON TYPE BRACKET_OPEN FUNCTION_BODY RETURN RETURN_VALUE SEMICOLON BRACKET_CLOSE ;
VOID_FUNCTION     ::= FUNC_T ID PARENTESIS_OPEN ARGUMENTS PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY RETURN SEMICOLON BRACKET_CLOSE ;
ARGUMENT_EX       ::= TYPE ID_OR_IDBRACKETS ;
ARGUMENT_EX       ::= TYPE REFERENCE_OP ID_OR_IDBRACKETS ;
ARGUMENTS         ::= MORE_ARGUMENTS ARGUMENT_EX ;
ARGUMENTS         ::= /*EMPTY*/ ; 
MORE_ARGUMENTS    ::= MORE_ARGUMENTS ARGUMENT_EX COMMA ;
MORE_ARGUMENTS    ::= /*EMPTY*/ ;
FUNCTION_BODY     ::= FUNCTION_BODY INSTRUCTION ;
FUNCTION_BODY     ::= /*EMPTY*/ ;
RETURN_VALUE      ::= EXPRESSION ;

// Define

DEFINE_EX   ::= DEFINE ID LITERAL SEMICOLON ;

// Typedef

TYPEDEF_EX     ::= TYPEDEF ID TYPE_TYPEDEF SEMICOLON ;
TYPE_TYPEDEF   ::= INT_T ;
TYPE_TYPEDEF   ::= BOOLEAN_T ;
TYPE_TYPEDEF   ::= ID ;
TYPE_TYPEDEF   ::= TYPE_TYPEDEF POINTER_OP ;
TYPE_TYPEDEF   ::= TYPE_TYPEDEF SQ_BRACKET_OPEN OPT_INTEGER SQ_BRACKET_CLOSE ;

// Asignation

DECLARATION_AND_ASSIGNATION_INS  ::= TYPE ID_OR_IDBRACKETS ASSIGNATION_OP EXPRESSION SEMICOLON ;
DECLARATION_AND_ASSIGNATION_INS  ::= TYPE ID_OR_IDBRACKETS ASSIGNATION_OP NEW_OP EXPRESSION SEMICOLON ;
ASSIGNATION_INS                  ::= EXPRESSION ASSIGNATION_OP EXPRESSION SEMICOLON ;
ASSIGNATION_INS                  ::= EXPRESSION ASSIGNATION_OP NEW_OP EXPRESSION SEMICOLON ;

// If

IF_INS      ::= IF PARENTESIS_OPEN EXPRESSION PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY BRACKET_CLOSE ELSE_INS ;
ELSE_INS    ::= ELSE BRACKET_OPEN FUNCTION_BODY BRACKET_CLOSE ;
ELSE_INS    ::= /*EMPTY*/ ;

// Switch

SWITCH_INS        ::= SWITCH PARENTESIS_OPEN EXPRESSION PARENTESIS_CLOSE BRACKET_OPEN CASES_INS DEFAULT_CASE BRACKET_CLOSE ;
CASES_INS         ::= CASES_INS CASE PARENTESIS_OPEN LITERAL PARENTESIS_CLOSE COLON FUNCTION_BODY ;
CASES_INS         ::= /*EMPTY*/;
DEFAULT_CASE      ::= DEFAULT COLON FUNCTION_BODY BREAK SEMICOLON ;

// While

WHILE_INS      ::= WHILE PARENTESIS_OPEN EXPRESSION PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY BRACKET_CLOSE ;
BREAK_INS      ::= BREAK SEMICOLON ;
CONTINUE_INS   ::= CONTINUE SEMICOLON ;

// For

FOR_INS  ::= FOR PARENTESIS_OPEN OPTIONAL_EXPRESSION SEMICOLON EXPRESSION SEMICOLON OPTIONAL_EXPRESSION PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY BRACKET_CLOSE ;
OPTIONAL_EXPRESSION  ::= EXPRESSION ;
OPTIONAL_EXPRESSION  ::= /*EMPTY*/ ; // TODO Ã±apa

// I/O

IO_INS  ::= INPUT_INS ;
IO_INS  ::= OUTPUT_INS ;
INPUT_INS   ::= INPUT_FUNC PARENTESIS_OPEN EXPRESSION PARENTESIS_CLOSE SEMICOLON ;
OUTPUT_INS  ::= OUTPUT_FUNC PARENTESIS_OPEN EXPRESSION PARENTESIS_CLOSE SEMICOLON ;

// Main

MAIN_INS    ::= FUNCTION MAIN PARENTESIS_OPEN PARENTESIS_CLOSE COLON INT_T BRACKET_OPEN FUNCTION_BODY RETURN INTEGER SEMICOLON BRACKET_CLOSE ;

// Boolean and arithmetic expresions

EXPRESSION        ::= B0 ;

B0                ::= B1 LESS_OR_EQ_OP B1 ;
// {: RESULT = fact; :};
B0                ::= B1 GREATER_OR_EQ_OP B1 ;
B0                ::= B1 LESS_OP B1 ;
B0                ::= B1 GREATER_OP B1 ;
B0                ::= B1 EQUAL_OP B1 ;
B0                ::= B1 NOT_EQUAL_OP B1 ;
B0                ::= B1 ;

B1                ::= B1 OR_OP B2 ;
B1                ::= B2 ;

B2                ::= B2 AND_OP B3 ;
B2                ::= B3 ;

B3                ::= NOT_OP B4 ;
B3                ::= B4 ;

B4                ::= E0 ;

E0                ::= E0 SUM_OP E1 ;
E0                ::= E0 SUBS_OP E1 ;
E0                ::= SUBS_OP E1 ;
E0                ::= E1 ;

E1                ::= E1 MULT_OP E2 ;
E1                ::= E1 DIV_OP E2 ;
E1                ::= E1 MOD_OP E2 ;
E1                ::= E2 ;

E2                ::= E3 POW_OP E3 ;
E2                ::= E3 ;

E3                ::= POINTER_OP E4 ;
E3                ::= E4 ;

E4                ::= E5 FIELD_ACCESS E5 ;
E4                ::= E5 ;

E5                ::= E5 SQ_BRACKET_OPEN EXPRESSION SQ_BRACKET_CLOSE ;
E5                ::= E5 PARENTESIS_OPEN EXPRESSION PARENTESIS_CLOSE ;
E5                ::= E6 ;

E6                ::= PARENTESIS_OPEN EXPRESSION PARENTESIS_CLOSE ;
E6                ::= TERMINAL ;

EXPRESSIONS          ::= MORE_EXPRESSIONS EXPRESSION ;
EXPRESSION           ::= /*EMPTY*/ ;
MORE_EXPRESSIONS     ::= MORE_EXPRESSIONS EXPRESSION COMMA ;
MORE_EXPRESSIONS     ::= /*EMPTY*/ ;

TERMINAL             ::= LITERAL ;
TERMINAL             ::= ID_EX ;

// Frequently used expresions
TYPE                 ::= INT_T ;
TYPE                 ::= BOOLEAN_T ;
TYPE                 ::= ID ;
TYPE                 ::= TYPE POINTER_OP ;

ID_OR_IDBRACKETS     ::= ID_OR_IDBRACKETS SQ_BRACKET_OPEN OPT_INTEGER SQ_BRACKET_CLOSE ;
ID_OR_IDBRACKETS     ::= ID ;

OPT_INTEGER          ::= INTEGER ;
OPT_INTEGER          ::= ID ;
OPT_INTEGER          ::= /*EMPTY*/ ;

INSTRUCTION          ::= ASSIGNATION_INS ;
INSTRUCTION          ::= IF_INS ;
INSTRUCTION          ::= SWITCH_INS ;
INSTRUCTION          ::= WHILE_INS ;
INSTRUCTION          ::= FOR_INS ;
INSTRUCTION          ::= BREAK_INS ;
INSTRUCTION          ::= CONTINUE_INS ;
INSTRUCTION          ::= IO_INS ;
INSTRUCTION          ::= DECLARATION ;
INSTRUCTION          ::= SEMICOLON ; // The last semicolon represents an empty instruction

ID_EX                ::= THIS FIELD_ACCESS ID ;
ID_EX                ::= ID ;

LITERAL              ::= INTEGER ;
LITERAL              ::= TRUE ;
LITERAL              ::= FALSE ;