package syntax.src;

import java_cup.runtime.*;
import lexicon.src.AnalizadorLexicoTiny;
import lexicon.src.LexiconUnit;
import errors.src.GestionErroresTiny;

scan with {: return getScanner().next_token(); :};
parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoTiny alex = (AnalizadorLexicoTiny)getScanner();
   alex.fijaGestionErrores(errores);
:};


terminal        INTEGER, ID, INT_T,SUM_OP, SUBS_OP,
                MULT_OP, DIV_OP, POW_OP, PARENTESIS_OPEN,
                PARENTESIS_CLOSE, BRACKET_OPEN, BRACKET_CLOSE,
                SQ_BRACKET_OPEN, SQ_BRACKET_CLOSE, LESS_OP,
                GREATER_OP, EQUAL_OP, LESS_OR_EQ_OP, GREATER_OR_EQ_OP,
                NOT_EQUAL_OP, BOOLEAN_T, AND_OP, OR_OP, NOT_OP, TRUE, FALSE,
                COMMA, COLON, SEMICOLON, CLASS_T, STRUCT_T, FIELD_ACCESS,
                FUNC_T, POINTER_OP, REFERENCE_OP, NEW_OP, TYPEDEF, DEFINE,
                ASSIGNATION_OP, IF, ELSE, SWITCH, CASE, BREAK,
                DEFAULT, WHILE, CONTINUE, INPUT_FUNC,
                OUTPUT_FUNC, RETURN, THIS, PUBLIC, PRIVATE, MAIN;

non terminal    S, S1,
                BT, CLASS_EX, CLASS_BODY, METHOD_START, VISIBILITY, METHODS, DECLARATION,
                FUNCTION, TYPED_FUNCTION, VOID_FUNCTION, ARGUMENT_EX, ARGUMENTS, MORE_ARGUMENTS, FUNCTION_BODY, RETURN_VALUE,
                DEFINE_EX,
                TYPEDEF_EX,
                ASSIGNATION_INS,
                IF_INS, ELSE_INS,
                SWITCH_INS, CASES_INS, DEFAULT_CASE, OPTIONAL_BREAK,
                WHILE_INS,
                IO_INS, INPUT_INS, OUTPUT_INS,
                MAIN_INS,
                EXPRESSION,
                B0, B1, B2, B3, B4, E0, E1, E2, E3, E4, E5, E6,
                OP_B0, OP_B1, OP_B2, OP_B3, OP_E0_BIN, OP_E0_UN, OP_E1, OP_E2, OP_E3, OP_E4,
                TERMINAL, EXPRESSIONS, MORE_EXPRESSIONS,
                TYPE, OPT_INTEGER, INSTRUCTION, ID_EX, LITERAL;

// Grammar start

S     ::= S1 MAIN_INS ;
S1    ::= S1 BT | S1 FUNCTION | empty ;

// Big types

BT                  ::= CLASS_EX | STRUCT_EX | DEFINE_EX | TYPEDEF_EX SEMICOLON ;
CLASS_EX            ::= CLASS_T ID BRACKET_OPEN CLASS_BODY BRACKET_CLOSE SEMICOLON ;
CLASS_BODY          ::= VISIBILITY DECLARATION CLASS_BODY | METHOD_START SEMICOLON ;
METHOD_START        ::= ID PARENTESIS_OPEN ARGUMENTS PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY BRACKET_CLOSE METHODS ;
VISIBILITY          ::= PUBLIC | PRIVATE ;
METHODS             ::= METHODS VISIBILITY FUNCTION | empty ;
DECLARATION         ::= TYPE ID SEMICOLON ;

// Functions

FUNCTION          ::= TYPED_FUNCTION | VOID_FUNCTION ;
TYPED_FUNCTION    ::= FUNC_T ID PARENTESIS_OPEN ARGUMENTS PARENTESIS_CLOSE COLON TYPE BRACKET_OPEN FUNCTION_BODY RETURN RETURN_VALUE SEMICOLON BRACKET_CLOSE ;
VOID_FUNCTION     ::= FUNC_T ID PARENTESIS_OPEN ARGUMENTS PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY RETURN SEMICOLON BRACKET_CLOSE ;
ARGUMENT_EX       ::= TYPE ID | TYPE REFERENCE_OP ID ;
ARGUMENTS         ::= MORE_ARGUMENTS ARGUMENT_EX | empty ; 
MORE_ARGUMENTS    ::= MORE_ARGUMENTS ARGUMENT_EX COMMA | empty ;
FUNCTION_BODY     ::= FUNCTION_BODY INSTRUCTION | empty ;
RETURN_VALUE      ::= EXPRESSION ;

// Define

DEFINE_EX   ::= DEFINE ID LITERAL SEMICOLON ;

// Typedef

TYPEDEF_EX  ::= TYPEDEF ID EXPRESSION SEMICOLON ;

// Asignation

ASSIGNATION_INS  ::= TYPE ID ASSIGNATION_OP EXPRESSION SEMICOLON ; | ID_EX ASSIGNATION_OP EXPRESSION SEMICOLON ;

// If

IF_INS      ::= IF PARENTESIS_OPEN EXPRESSION PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY BRACKET_CLOSE ELSE_INS ;
ELSE_INS    ::= ELSE BRACKET_OPEN FUNCTION_BODY BRACKET_CLOSE | empty ;

// Switch

SWITCH_INS        ::= SWITCH PARENTESIS_OPEN ID_EX PARENTESIS_CLOSE BRACKET_OPEN CASES_INS DEFAULT_CASE BRACKET_CLOSE ;
CASES_INS         ::= CASES_INS CASE PARENTESIS_OPEN LITERAL PARENTESIS_CLOSE COLON FUNCTION_BODY OPTIONAL_BREAK | empty;
DEFAULT_CASE      ::= DEFAULT COLON FUNCTION_BODY BREAK SEMICOLON ;
OPTIONAL_BREAK    ::= BREAK SEMICOLON | empty ;

// While

WHILE_INS   ::= WHILE PARENTESIS_OPEN EXPRESSION PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY BRACKET_CLOSE ;

// I/O

IO_INS  ::= INPUT_INS | OUTPUT_INS ;
INPUT_INS   ::= INPUT_FUNC PARENTESIS_OPEN ID_EX PARENTESIS_CLOSE SEMICOLON ;
OUTPUT_INS  ::= OUTPUT_FUNC PARENTESIS_OPEN EXPRESSION PARENTESIS_CLOSE SEMICOLON ;

// Main

MAIN_INS    ::= FUNCTION MAIN PARENTESIS_OPEN PARENTESIS_CLOSE COLON INT_T BRACKET_OPEN FUNCTION_BODY RETURN INTEGER SEMICOLON BRACKET_CLOSE ;

// Boolean and arithmetic expresions

EXPRESSION        ::= B0 ;

B0                ::= B1 OP_B0 B1 | B1 ;
B1                ::= B1 OP_B1 B2 | B2 ;
B2                ::= B2 OP_B2 B3 | B3 ;
B3                ::= OP_B3 B4 | B4 ;
B4                ::= E0 ;
E0                ::= E0 OP_E0_BIN E1 | OP_E0_UN E1 | E1 ;
E1                ::= E1 OP_E1 E2 | E2 ;
E2                ::= E3 OP_E2 E3 | E3 ;
E3                ::= OP_E3 E4 | E4 ;
E4                ::= E5 OP_E4 E5 | E5 ;
E5                ::= E5 BRACKET_OPEN B0 BRACKET_CLOSE | E6 ;
E6                ::= PARENTESIS_OPEN B0 PARENTESIS_CLOSE | TERMINAL ;

OP_B0             ::= LESS_OR_EQ_OP | GREATER_OR_EQ_OP | LESS_OP | GREATER_OP | EQUAL_OP | NOT_EQUAL_OP ;
OP_B1             ::= OR_OP ;
OP_B2             ::= AND_OP ;
OP_B3             ::= NOT_OP ;
OP_E0_BIN         ::= SUM_OP | SUBS_OP ; // Binary operators for E0
OP_E0_UN          ::= SUBS_OP ; // Unitary operators for E0
OP_E1             ::= MULT_OP | DIV_OP ;
OP_E2             ::= POW_OP ;
OP_E3             ::= POINTER_OP ;
OP_E4             ::= FIELD_ACCESS ;

TERMINAL          ::= LITERAL | ID_EX | ID_EX PARENTESIS_OPEN EXPRESSIONS PARENTESIS_CLOSE ;
EXPRESSIONS       ::= MORE_EXPRESSIONS EXPRESSION | empty ;
MORE_EXPRESSIONS  ::= MORE_EXPRESSIONS EXPRESSION COMMA | empty ;

// Frequently used expresions
TYPE                 ::= INT_T | BOOLEAN_T | ID | TYPE POINTER_OP | TYPE SQ_BRACKET_OPEN OPT_INTEGER SQ_BRACKET_CLOSE ;
OPT_INTEGER          ::= INTEGER | empty ;
INSTRUCTION          ::= ASSIGNATION_INS | IF_INS | SWITCH_INS | WHILE_INS | IO_INS | SEMICOLON ; // The last semicolon represents an empty instruction
ID_EX                ::= THIS FIELD_ACCESS ID | ID ;
LITERAL              ::= INTEGER | TRUE | FALSE ;